#include "imports/stdlib.fc";
;; DEC 	OCT 	HEX 	BIN 	Symbol
;; 33   041     21  00100001    !
;; 46   056     2E	00101110    .
;; 83   123     53  01010011    S
;; 69   105     45  01000101    E
;; 88   130     58  01011000    X
;; 63   077     3F  00111111    ?

;; n = rows, m = cols, max is 31x31
const int key_shift = 5;                ;; 31 takes  5 bits
const int node_bsize = key_shift * 2;   ;; 31 << 5 + 31 takes 10 bits
const int value_bsize = 32;             ;; to store 31x31 of Xs (weight 1M)

(int) tlen (tuple t) asm "TLEN";
forall X -> tuple tpush(tuple t, X value) asm "TPUSH";
forall X -> (tuple, ()) ~tpush(tuple t, X value) asm "TPUSH";

(int, int) find_start_end_nodes(int rows, int cols, tuple maze) {
    int start_not_found? = true;
    int end_not_found? = true;
    int node_start = 0;
    int node_end = 0;

    int i = 0;
    while ( (i < rows) & (start_not_found? | end_not_found?) ) {
        int j = 0;
        while ( (j < cols) & (start_not_found? | end_not_found?) ) {
            if (maze.at(i).at(j) == "S"u) {
                node_start = (i << key_shift) + j;
                start_not_found? = false;
            }
            if (maze.at(i).at(j) == "E"u) {
                node_end = (i << key_shift) + j;
                end_not_found? = false;
            }

            j += 1;
        }

        i += 1;
    }

    return (node_start, node_end);
}

(slice) sl(int value, int prev_node) inline {
    return begin_cell()
        .store_uint(value, value_bsize)
        .store_uint(prev_node, node_bsize)
    .end_cell().begin_parse();
}

(cell, ()) store_value(cell maze_dict, int node, int new_value, int prev_node) inline {
    (slice value, int found?) = maze_dict.udict_get?(node_bsize, node);
    ifnot (found?) {
        maze_dict~udict_set(node_bsize, node, sl(new_value, prev_node));
    } else {
        int current_value = value.preload_uint(value_bsize);
        if (new_value < current_value) {
            maze_dict~udict_set(node_bsize, node, sl(new_value, prev_node));
        }
    }
    return (maze_dict, ());
}

(int, int, int, tuple, tuple, cell) solve_work(int rows, int cols, tuple maze_input) method_id {
    (int x, int q, int s, tuple maze_result, cell maze_dict) = (0, 0, 0, empty_tuple(), new_dict());

    ;; find coordinates of start and end nodes
    (int node_start, int node_end) = find_start_end_nodes(rows, cols, maze_input);
    
    ;; process input maze
    int prev_node = node_end;
    int value = 4200000000;
    maze_dict~store_value(313, 13, 12);

    ;; generate output maze with a path 
    int i = 0;
    while (i < rows) {
        int j = 0;
        tuple row = empty_tuple();
        while (j < cols) {
            int cellM = maze_input.at(i).at(j);
            if(cellM == "S"u) { cellM = "E"u; }
            elseif(cellM == "E"u) { cellM = "S"u; }
            row~tpush(cellM);

            j += 1;
        }
        maze_result~tpush(row);

        i += 1;
    }

    return(x, q, s, maze_input, maze_result, maze_dict);
}


(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    (int x, int q, int s, _, tuple maze_solved, _) = solve_work(n, m, maze);

    return(-1, 0, 0, null());
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}
