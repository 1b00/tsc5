#include "imports/stdlib.fc";
;; DEC 	OCT 	HEX 	BIN 	Symbol
;; 33   041     21  00100001    !
;; 46   056     2E	00101110    .
;; 83   123     53  01010011    S
;; 69   105     45  01000101    E
;; 88   130     58  01011000    X
;; 63   077     3F  00111111    ?

;; n = rows, m = cols, max is 31x31
;; const key_shift = 5;                ;; 31 takes  5 bits
const key_bit_size = 32; ;; 31 << 5 + 31 takes 10 bits

(int) tlen (tuple t) asm "TLEN";
forall X -> tuple tpush(tuple t, X value) asm "TPUSH";
forall X -> (tuple, ()) ~tpush(tuple t, X value) asm "TPUSH";

(int, int, int, tuple, cell) solve_work(int rows, int cols, tuple maze) method_id {
    (int x, int q, int s, cell maze_dict) = (0, 0, 0, new_dict());
    ;; int x = 0;
    ;; int q = 0;
    ;; int s = 0;
    ;; cell maze_dict = new_dict();
    ;; int rows = maze.tlen();
    ;; int cols = maze.at(0).tlen();
    ;; maze_dict~udict_set(key_bit_size, 1 << 5, maze.at(0).at(0));
    ;; maze_dict~udict_set(key_bit_size, 2, maze.at(0).at(1));
    ;; maze_dict~udict_set(key_bit_size, 3, maze.at(1).at(0));
    ;; maze_dict~udict_set(key_bit_size, 4, maze.at(1).at(1));
    int i = 0;
    while (i < rows) {
        int j = 0;
        while (j < cols) {
            int node = (i * 100) + j;
            maze_dict~udict_set(key_bit_size, node, maze.at(i).at(j));
            
            j += 1;
        }

        i += 1;
    }

    return(x, q, s, maze, maze_dict);
}

(int, int, int, tuple, cell) whilewhile(int rows, int cols, tuple maze) method_id {
    (int x, int q, int s, cell maze_dict) = (0, 0, 0, new_dict());

    int i = 0;
    while (i < rows) {
        int j = 0;
        while (j < cols) {
            int node = (i * 100) + j;
            maze_dict~udict_set(key_bit_size, node, maze.at(i).at(j));
            
            j += 1;
        }

        i += 1;
    }
    return(-1, 0, 0, null(), maze_dict);
}

(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    (int x, int q, int s, tuple maze_solved, _) = whilewhile(n, m, maze);

    return(-1, 0, 0, null());
}

;; (tuple) testt (int n, int m, tuple in_maze) method_id {
;;     tuple maze = empty_tuple();
;;     tuple maze_row = empty_tuple();
;;     maze_row~tpush(".");
;;     maze_row~tpush("X");
;;     maze~tpush(maze_row);
;;     maze_row = empty_tuple();
;;     maze_row~tpush("S");
;;     maze_row~tpush("?");
;;     maze~tpush(maze_row);
;;     (int x, int q, int s, tuple solved_maze) = solve(2, 2, maze);
;;     ~dump(x);
;;     ~dump(q);
;;     ~dump(s);
;;     ~dump(solved_maze);
;;     return in_maze;
;; }

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}
