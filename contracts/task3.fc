#include "imports/stdlib.fc";

;; Hey, I put the recv_internal function from the bottom of the file to the top, fully replicating the template in terms of function order, and it made me pass the tests right away from 4/10. Maybe you have a similar issue?
;; Oh and I left the msg_value and balance as they were in the task, I didn't try swapping them yet so not sure if that matters at all.
;; Did you use set_code in addition to set_c3? That got me from 3/10 to 4/10 then I did what Andy said to get to 10/10
;; No I used only set_c3 :( We should use set_c3 for both migration_code and new_code right?
;; Yes and set_code for new_code
;; If expected_version == current_version, we do not need to set_code(new_code) right? Only have to call process_message and set_data
;; Yes, also make sure to not migrate the storage if there are missing links in the migration chain
;; how do we transfrom cell to cont?
;; set_c3(code.begin_parse().bless());
;; storage.process_message(...) will not work, but process_message(storage, ...) will.
;; Does this mean that the migrations dictionary would be empty? Or the migration code would be empty cell?
;; No. It'd be a normal dictionary, it'd have a key 1 and the value would be 4 and then no migration code in a reference (according to TLB)
;; TLB can be confusing, don't hesitate to ask more if you don't understand something.

;; Hey, I put the recv_internal function from the bottom of the file to the top, fully replicating the template in terms of function order,
;;  and it made me pass the tests right away from 4/10. Maybe you have a similar issue?
;; Oh and I left the msg_value and balance as they were in the task, I didn't try swapping them yet so not sure if that matters at all.
;; Did you use set_code in addition to set_c3? That got me from 3/10 to 4/10 then I did what Andy said to get to 10/10
;; No I used only set_c3 :( We should use set_c3 for both migration_code and new_code right?
;; Yes and set_code for new_code
;; If version_expected == version_current, we do not need to set_code(new_code) right? Only have to call process_message and set_data
;; Yes, also make sure to not migrate the storage if there are missing links in the migration chain
;; how do we transfrom cell to cont?
;; set_c3(code.begin_parse().bless());
;; storage.process_message(...) will not work, but process_message(storage, ...) will.
;; Does this mean that the migrations dictionary would be empty? Or the migration code would be empty cell?
;; No. It'd be a normal dictionary, it'd have a key 1 and the value would be 4 and then no migration code in a reference (according to TLB)
;; TLB can be confusing, don't hesitate to ask more if you don't understand something.

;; All the code in recv_internal, get_storage, wrap_storage, and version
;; serves as an example of the intended structure.

;; The provided code is an "empty wrapper." It:
;; + Parses "wrapped" incoming messages (discards versioning information)
;; + "Wraps" the call to the version-specific process_message
;; + Implements "get_storage" for version-specific get-methods
;; However, it does not yet implement any upgrade logic, which is your task.

;; The empty wrapper is provided to demonstrate
;; how version-specific code is intended to be "wrapped" and interacted with.
;; You may delete and rewrite as needed,
;; but the final implementation must adhere to the same structure


;; global int version_current;


;; recv_internal
;;     Handles internal messages from users.
;;     Checks if an update is necessary.
;;     if an update is needed - it migrates the storage and updates the contract code;
;;       if the update is needed but update code isn't attached, it throws an error 200.
;;     Executes process_message and updates storage.

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; expected_version:uint32 new_code:(Maybe ^Cell) migrations:(HashmapE 32 MigrationPayload) payload:^Cell = InternalMsgBody;
    ;;                      new_version:uint32 migration_code:(Maybe ^Cell) = MigrationPayload;
    int version_expected = in_msg_body~load_uint(32);
    ;; ;; Next is a bit indicating whether update code is attached. If the bit is set to 1, it is followed by the update code in a reference.
    cell new_code = in_msg_body~load_maybe_ref();
    cell migrations = in_msg_body~load_dict();
    cell payload = in_msg_body~load_ref();
    
    ;; ;; Let's agree that the first call to the smart contract will occur with version_expected = 0, followed by an empty migrations dictionary.
    ;; ;; During this first call, your template must set the version to 1 for future interactions and finish the execution.
    ;; if ( (version_expected == 0) & (migrations.dict_empty?())) { ;; ??? & (migrations.dict_empty?())
        ;; version_current = 1;
        ;; return ();
    ;; }

    ;; if (version_expected < version_current) {
    ;;     throw(1); ;; ???
    ;; }

    ;; if (version_expected > version_current) {
    ;;     ;; if the update is needed but update code isn't attached, it throws an error 200.
    ;;     throw_if(200, cell_null?(new_code));

    ;;     ;; expected_version:uint32 new_code:(Maybe ^Cell) migrations:(HashmapE 32 MigrationPayload) payload:^Cell = InternalMsgBody;
    ;;     ;;                      new_version:uint32 migration_code:(Maybe ^Cell) = MigrationPayload;
    ;;     cell migrations_todo = new_dict();
    ;;     int version_from = version_current;
    ;;     (slice migration_payload, int migration_found?) = migrations.udict_get?(32, version_from);
    ;;     throw_unless(400, migration_found?);
    ;;     while (migration_found?) {
    ;;         int version_to = migration_payload~load_uint(32);
    ;;         throw_unless(400, version_to > version_from);
    ;;         throw_if(400, version_to > version_expected);
    ;;         cell migration_code = migration_payload~load_maybe_ref();
    ;;         ifnot (cell_null?(migration_code)) {
    ;;             migrations_todo~udict_set(32, version_to, migration_code.begin_parse());
    ;;         }
    ;;         if (version_to == version_expected) {
    ;;             migration_found? = false;
    ;;         } else {
    ;;             version_from = version_to;
    ;;             (migration_payload, migration_found?) = migrations.udict_get?(32, version_from);
    ;;             throw_unless(400, migration_found?);
    ;;         }
    ;;     }
    ;;     (int version_to, slice migration_code, int migration_found?) = migrations_todo.udict_get_min?(32);
    ;;     while (migration_found?) {
    ;;         set_c3(migration_code.bless());
    ;;         set_data(wrap_storage(version_to, migrate_one(get_storage())));
    ;;         (version_to, migration_code, migration_found?) = migrations_todo.udict_get_next?(32, version_to);
    ;;     }

    ;;     set_code(new_code);
    ;;     set_c3(new_code.begin_parse().bless());
    ;;     version_current = version_expected;
    ;; }

    ;; ;; ---
    ;; ;; here you should check if it's the first call or not based on `version_expected` as stated in the task
    ;; ;; if it is the first call, wrap the storage and finish execution by returning from the function
    ;; ;; ---

    slice ds = get_data().begin_parse();
    cell storage = ds~load_ref();
    
    storage = process_message(storage, msg_value, my_balance, in_msg_full, payload.begin_parse());

    set_data(wrap_storage(-2, storage)); ;; -2 is just a random placeholder for the version
}

;; cell get_storage() - Returns the main smart contract's unwrapped storage.
;; Ensure get_storage returns the storage used in process_message.
cell get_storage() {
    slice cs = get_data().begin_parse();

    ;; Logic to extract the storage on which the version-specific process_message and get-methods operate
    cell storage = cs~load_ref();

    return storage;
}

;; cell wrap_storage(int version_id, cell storage) - Wraps the main contract's storage with versioning data.
cell wrap_storage(int version_id, cell storage) {
    ;; add additional data required for versioning in this cell
    return begin_cell()
        .store_ref(storage)
    .end_cell();
}

;; int version() method_id - Returns the smart contract's current version.
;; Return the current version of the smart contract
int version() method_id {
    ;; return version_current;
    return -2; ;; Not implemented
}

;; <<<<< Custom version-specific code begins
;; This section (everything between << and >> characters) will be fully substituted for each version.
;; This is an IMPORTANT part, and these exact lines with <<<<< and >>>>> must be present in your code for the testing system to work correctly.
;; All the code provided here serves as an example of the version-code, which your update code must be compatible with.
;; Refer to the "3-example" directory for more version examples.

;; from counter-v0.fc
cell process_message(cell storage, int msg_value, int balance, cell in_msg_full, slice in_msg_body) impure {
    slice cs = storage.begin_parse();
    int current_amount = cs.preload_uint(32);
    return begin_cell().store_uint(current_amount + 1, 32).end_cell();
}

cell migrate_one(cell old_storage) { ;; it's just a placeholder that is required for correct compilation
    return old_storage;
}

;; Custom version-specific code ends >>>>>
