#include "imports/stdlib.fc";

;; Hey, I put the recv_internal function from the bottom of the file to the top, fully replicating the template in terms of function order, and it made me pass the tests right away from 4/10. Maybe you have a similar issue?
;; Oh and I left the msg_value and balance as they were in the task, I didn't try swapping them yet so not sure if that matters at all.
;; Did you use set_code in addition to set_c3? That got me from 3/10 to 4/10 then I did what Andy said to get to 10/10
;; No I used only set_c3 :( We should use set_c3 for both migration_code and new_code right?
;; Yes and set_code for new_code
;; If expected_version == current_version, we do not need to set_code(new_code) right? Only have to call process_message and set_data
;; Yes, also make sure to not migrate the storage if there are missing links in the migration chain
;; how do we transfrom cell to cont?
;; set_c3(code.begin_parse().bless());
;; storage.process_message(...) will not work, but process_message(storage, ...) will.
;; Does this mean that the migrations dictionary would be empty? Or the migration code would be empty cell?
;; No. It'd be a normal dictionary, it'd have a key 1 and the value would be 4 and then no migration code in a reference (according to TLB)
;; TLB can be confusing, don't hesitate to ask more if you don't understand something.

;; All the code in recv_internal, get_storage, wrap_storage, and version
;; serves as an example of the intended structure.

;; The provided code is an "empty wrapper." It:
;; + Parses "wrapped" incoming messages (discards versioning information)
;; + "Wraps" the call to the version-specific process_message
;; + Implements "get_storage" for version-specific get-methods
;; However, it does not yet implement any upgrade logic, which is your task.

;; The empty wrapper is provided to demonstrate
;; how version-specific code is intended to be "wrapped" and interacted with.
;; You may delete and rewrite as needed,
;; but the final implementation must adhere to the same structure

() recv_internal(int msg_value, int balance, cell in_msg_full, slice in_msg_body) impure {
    in_msg_body~skip_bits(32); ;; Skip the expected version
    in_msg_body~load_maybe_ref(); ;; Skip the expected code
    in_msg_body~load_dict(); ;; Skip migrations
    cell payload = in_msg_body~load_ref();

    ;; ---
    ;; here you should check if it's the first call or not based on `expected_version` as stated in the task
    ;; if it is the first call, wrap the storage and finish execution by returning from the function
    ;; ---

    slice ds = get_data().begin_parse();
    cell storage = ds~load_ref();
    
    storage = process_message(storage, msg_value, balance, in_msg_full, payload.begin_parse());

    set_data(wrap_storage(-2, storage)); ;; -2 is just a random placeholder for the version
}

cell get_storage() {
    slice cs = get_data().begin_parse();

    ;; Logic to extract the storage on which the version-specific process_message and get-methods operate
    cell storage = cs~load_ref();

    return storage;
}

cell wrap_storage(int version_id, cell storage) {
    ;; add additional data required for versioning in this cell
    return begin_cell()
        .store_ref(storage)
    .end_cell();
}

;; Return the current version of the smart contract
int version() method_id {
    return -2; ;; Not implemented
}

;; <<<<< Custom version-specific code begins
;; This section (everything between << and >> characters) will be fully substituted for each version.
;; This is an IMPORTANT part, and these exact lines with <<<<< and >>>>> must be present in your code for the testing system to work correctly.
;; All the code provided here serves as an example of the version-code, which your update code must be compatible with.
;; Refer to the "3-example" directory for more version examples.

;; from counter-v0.fc
cell process_message(cell storage, int msg_value, int balance, cell in_msg_full, slice in_msg_body) impure {
    slice cs = storage.begin_parse();
    int current_amount = cs.preload_uint(32);
    return begin_cell().store_uint(current_amount + 1, 32).end_cell();
}

cell migrate_one(cell old_storage) { ;; it's just a placeholder that is required for correct compilation
    return old_storage;
}

;; Custom version-specific code ends >>>>>
