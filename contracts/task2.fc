#include "imports/stdlib.fc";


;; add_user#368ddef3 query_id:uint64 address:MsgAddressInt share:uint32 = InternalMsgBody;
const int op::add_user = 0x368ddef3;
;; remove_user#278205c8 query_id:uint64 address:MsgAddressInt = InternalMsgBody;
const int op::remove_user = 0x278205c8;
;; split_ton#068530b3 query_id:uint64 = InternalMsgBody;
const int op::split_ton = 0x068530b3;
;; transfer_notification#7362d09c query_id:uint64 amount:Coins = InternalMsgBody;
const int op::transfer_notification = 0x7362d09c;


;; admin_address: MsgAddressInt
;; users: (HashmapE 256 uint32) Note: uint256 is data bits of address. Workchain = 0.
;; CUSTOM FIELDS:
;; total_share: uint32
(slice, cell) load_data() impure inline {
    slice ds = get_data().begin_parse();
    return(
        ds~load_msg_addr()  ;; admin_address
        ,ds~load_dict()     ;; users
        ;; ,slice_empty?(ds) ? 0 : ds~load_uint(32)   ;; total_share
    );
}

;; get_users: returns a dictionary with 256 bits keys (user addresses' data bits) and the value is uint32, which means user share.
cell get_users() method_id {
    ;; cell users = new_dict();
    ;; (_, users) = load_data();
    var ds = get_data().begin_parse().skip_bits(2 + 1 + 8 + 256);
    return ds~load_dict();
    ;; return(users);
}

;; get_user_share(slice user_address): returns the user's share. It is guaranteed that the user is in the storage.
slice get_user_share(slice user_address) method_id {
    cell users = new_dict();
    ;; (_, users) = load_data();
    var ds = get_data().begin_parse().skip_bits(2 + 1 + 8 + 256);
    users = ds~load_dict();
    (_, int addr) = parse_std_addr(user_address);
    (slice share, _) = users.udict_get?(256, addr);
    return(share); ;;.preload_uint(32));
}

() store_data(var data) impure inline {
    (
        slice admin_address
        ,cell users
        ;; ,int total_share
    ) = data;

    set_data(
        begin_cell()
            .store_slice(admin_address)
            .store_dict(users)
            ;; .store_uint(total_share, 32)
        .end_cell()
    );
}

;; (slice) uint_to_slice(int number, int bit_depth) inline {
;;     return begin_cell().store_uint(number, bit_depth).end_cell().begin_parse();
;; }

;; (slice) gen_address(int addr) inline {
;;     return begin_cell().store_uint(4, 3).store_uint(0, 8).store_uint(addr, 256).end_cell().begin_parse();
;; }

(slice) generate_internal_address(int addr) {
    ;; addr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:bits256  = MsgAddressInt;
    int workchain_id = 0;

    return begin_cell()
        .store_uint(2, 2) ;; addr_std$10
        .store_uint(0, 1) ;; anycast nothing
        .store_int(workchain_id, 8)
        .store_uint(addr, 256)
    .end_cell().begin_parse();
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    cell users = new_dict();
    (slice admin_address, users) = load_data();

    if (op == op::add_user) {
        ;; add_user#368ddef3 query_id:uint64 address:MsgAddressInt share:uint32 = InternalMsgBody;

        ;; The contract accepts the message, checks that it came from the admin, and if so, adds the user to its storage.
        ;; If the user is already in the storage, then it is necessary to update its share to a new one.
        
        ;; If the message did not come from the admin, the contract should throw error 120.
        throw_unless(120, equal_slices(sender_address, admin_address));

        accept_message();

        (slice address, slice share) = load_msg_addr(in_msg_body);
        (_, int addr) = parse_std_addr(address);
        ;; int share = in_msg_body~load_uint(32);
        ;; users~udict_set(256, addr, uint_to_slice(share, 32));
        ;; (slice current_share, int found?) = users.udict_get?(256, addr);
        ;; if (found?) {
        ;;     total_share = total_share - current_share.preload_uint(32);
        ;; }
        users~udict_set(256, addr, share);
        store_data(admin_address, users); ;;, total_share + share.preload_uint(32));
    }
    elseif (op == op::remove_user) {
        ;; remove_user#278205c8 query_id:uint64 address:MsgAddressInt = InternalMsgBody;

        ;; The contract accepts the message, checks that it came from the admin, and if so, it removes the user from its storage.

        ;; If the message did not come from the admin, the contract should throw error 120.
        throw_unless(120, equal_slices(sender_address, admin_address));

        accept_message();

        (_, int addr) = parse_std_addr(in_msg_body);
        (slice share, int found?) = users~udict_delete_get?(256, addr);
        ;; If the user is not in the storage, it should throw error 121.
        throw_unless(121, found?);

        ;; accept_message();

        store_data(admin_address, users); ;;, total_share - share.preload_uint(32));
    }
    elseif (op == op::split_ton) {
        ;; split_ton#068530b3 query_id:uint64 = InternalMsgBody;

        ;; The contract accepts the message, distributes the TON to users according to their shares.
        ;; Transactions must be sent with mode = 1 and no body.

        ;; If there are no users, error 122 must be thrown
        throw_if(122, users.dict_empty?());

        ;; return();

        ;; accept_message();

        ;; int amount = slice_empty?(cs) ? 0 : cs~load_coins();

        ;; (int addr, slice share, int next) = users.udict_get_min?(256);
        ;; while (next) {
        ;;     var msg = begin_cell()
        ;;         .store_uint(0x10, 6)
        ;;         .store_slice(generate_internal_address(addr))
        ;;         .store_coins(share.preload_uint(32) * amount / total_share)
        ;;         .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);
        ;;     send_raw_message(msg.end_cell(), 1);
            
        ;;     (addr, share, next) = users.udict_get_next?(256, addr);
        ;; }
    }
    elseif (op == op::transfer_notification) {
        ;; transfer_notification#7362d09c query_id:uint64 amount:Coins = InternalMsgBody;

        ;; int amount = slice_empty?(in_msg_body) ? 0 : in_msg_body~load_coins();

        ;; If there are no users, then error 122 must be thrown.
        throw_if(122, users.dict_empty?());

        ;; return();

        ;; accept_message();

        ;; (int addr, slice share, int next) = users.udict_get_min?(256);
        ;; while (next) {
        ;;     var msg = begin_cell()
        ;;         .store_uint(0x10, 6)
        ;;         .store_slice(generate_internal_address(addr))
        ;;         .store_coins(share.preload_uint(32) * amount / total_share)
        ;;         .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);
        ;;     send_raw_message(msg.end_cell(), 1);
            
        ;;     (addr, share, next) = users.udict_get_next?(256, addr);
        ;; }
        

    }

}
