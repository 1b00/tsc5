#include "imports/stdlib.fc";


;; add_user#368ddef3 query_id:uint64 address:MsgAddressInt share:uint32 = InternalMsgBody;
const int op::add_user = 0x368ddef3;
;; remove_user#278205c8 query_id:uint64 address:MsgAddressInt = InternalMsgBody;
const int op::remove_user = 0x278205c8;
;; split_ton#068530b3 query_id:uint64 = InternalMsgBody;
const int op::split_ton = 0x068530b3;
;; transfer_notification#7362d09c query_id:uint64 amount:Coins = InternalMsgBody;
const int op::transfer_notification = 0x7362d09c;


;; admin_address: MsgAddressInt
;; users: (HashmapE 256 uint32) Note: uint256 is data bits of address. Workchain = 0.
(slice, cell) load_data() impure inline {
    slice ds = get_data().begin_parse();
    return(
        ds~load_msg_addr(), ;; admin_address
        ds~load_dict()      ;; users
    );
}

;; get_users: returns a dictionary with 256 bits keys (user addresses' data bits) and the value is uint32, which means user share.
cell get_users() method_id {
    (_, cell users) = load_data();
    return(users);
}

;; get_user_share(slice user_address): returns the user's share. It is guaranteed that the user is in the storage.
int get_user_share(slice user_address) method_id {
    (_, cell users) = load_data();
    (_, int addr) = parse_std_addr(user_address);
    (slice share, _) = users.udict_get?(256, addr);
    return(share.preload_uint(32));
}

() store_data(var data) impure inline {
    (
        slice admin_address,
        cell users
    ) = data;

    set_data(
        begin_cell()
            .store_slice(admin_address)
            .store_dict(users)
        .end_cell()
    );
}

(slice) uint_to_slice(int number, int bit_depth) inline {
    return begin_cell().store_uint(number, bit_depth).end_cell().begin_parse();
}


() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    (slice admin_address, cell users) = load_data();

    if (op == op::add_user) {
        ;; add_user#368ddef3 query_id:uint64 address:MsgAddressInt share:uint32 = InternalMsgBody;

        ;; The contract accepts the message, checks that it came from the admin, and if so, adds the user to its storage.
        ;; If the user is already in the storage, then it is necessary to update its share to a new one.
        ;; If the message did not come from the admin, the contract should throw error 120.
        throw_unless(120, equal_slices(sender_address, admin_address));
        ;; accept_message();
        ;; slice address = in_msg_body~load_msg_addr();
        (slice address, slice share) = load_msg_addr(in_msg_body);
        (_, int addr) = parse_std_addr(address);
        ;; int share = in_msg_body~load_uint(32);
        ;; users~udict_set(256, addr, uint_to_slice(share, 32));
        users~udict_set(256, addr, share);
        store_data(admin_address, users);
    }
    elseif (op == op::remove_user) {
        ;; remove_user#278205c8 query_id:uint64 address:MsgAddressInt = InternalMsgBody;

        ;; The contract accepts the message, checks that it came from the admin, and if so, it removes the user from its storage.
        ;; If the message did not come from the admin, the contract should throw error 120.
        throw_unless(120, equal_slices(sender_address, admin_address));
        (_, int addr) = parse_std_addr(in_msg_body);
        ;; If the user is not in the storage, it should throw error 121.
        int found? = users~udict_delete?(256, addr);
        throw_unless(121, found?);
        store_data(admin_address, users);
    }
    elseif (op == op::split_ton) {
        ;; split_ton#068530b3 query_id:uint64 = InternalMsgBody;

    }
    elseif (op == op::transfer_notification) {
        ;; transfer_notification#7362d09c query_id:uint64 amount:Coins = InternalMsgBody;
        
    }

}


;; `balance` - (uint256) количество жетонов на кошельке.
;; `owner` - (MsgAddress) адрес владельца кошелька;
;; `jetton` - (MsgAddress) адрес мастер контракта;
;; `jetton_wallet_code` - (cell) с кодом этого кошелька;

;; То есть просто выгрузить постоянные данные:

;; (int, slice, slice, cell) get_wallet_data() method_id {
;;   return load_data();
;; }
